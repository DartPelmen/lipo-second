/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package lipo.first

import java.util.regex.Pattern

val text = "Var a, b, c; abcdef = 2 + 1 t = 4"
enum class LexemNames{
    COMMA,DELIMITER,PLUS,MINUS,MULT,DIV,EQ,LEFT_BRACKET,RIGHT_BRACKET,TYPE_NAME,SPACE, IDENT, CONST
}
data class Lexem(val lexem: LexemNames, val value: String)
val lexems = listOf(Lexem(LexemNames.DELIMITER,";"),
    Lexem(LexemNames.COMMA,","),
    Lexem(LexemNames.PLUS,"\\+"),
    Lexem(LexemNames.MINUS,"-"),
    Lexem(LexemNames.MULT,"\\*"),
    Lexem(LexemNames.DIV,"/"),
    Lexem(LexemNames.EQ,"="),
    Lexem(LexemNames.LEFT_BRACKET,"\\("),
    Lexem(LexemNames.RIGHT_BRACKET,"\\)"),
    Lexem(LexemNames.TYPE_NAME,"Var"),
    Lexem(LexemNames.SPACE," ")
)
fun main() {
    val lexemMap = HashMap<Lexem,MutableList<Int>>()
    if(text.contains(";")){
        var variables = text.substring(0, text.indexOf(lexems[0].value)+1)
        val assigments = text.substring(text.indexOf(lexems[0].value)+1).trim()
        println("VARIABLES ARE $variables")
        println("ASSIGMENTS ARE $assigments")
        println(firstIndexOfUndefined(variables))
        var count = 0

        lexems.forEach {
            lexem -> print("LEXEM ${lexem.lexem}: ")
            if(!lexemMap.contains(lexem)){
                lexemMap[lexem] = mutableListOf()
            }
            var i = variables.indexOf(lexem.value)
            while (i != -1){
                var placeholder = ""
                lexemMap[lexem]!!.add(i)
                for(j in lexem.value.indices){
                    placeholder += "|"

                }
                print("$i, ")
                variables = variables.replaceFirst(lexem.value,placeholder)
                i = variables.indexOf(lexem.value)
            }
            println()
            println("NOW VARIABLES ARE $variables")

        }
        val p = Pattern.compile("\\w+")
        val m = p.matcher(variables)
        m.results().forEach {
            val lx = Lexem(LexemNames.IDENT,variables.substring(it.start(),it.end()))
            lexemMap.put(lx, mutableListOf(it.start()))
            println("RES: ${variables.substring(it.start(),it.end())} WITH POS ${it.start()}")
        }
        lexemMap.forEach {

            it.value.forEach {x->
                if(count<x)
                    count = x
            }

        }
        val lexemList = MutableList<LexemNames?>(count+1,{null})

        lexemMap.forEach {
            it.value.forEach { x->
                lexemList[x] = it.key.lexem
            }
        }
        while (lexemList.contains(null)){
            lexemList.removeAt(lexemList.indexOf(null))
        }
        lexemList.forEach {
            print( "$it ")
        }
        println()
        if(lexemList.first()!= LexemNames.TYPE_NAME && lexemList.last() != LexemNames.DELIMITER){
            println("Ошибка в объявлении типа или точке с запятой!")
        } else{
            println("правило: ${LexemNames.TYPE_NAME} ${LexemNames.SPACE} LIST<VARIABLES> ${LexemNames.DELIMITER}")
            lexemList.removeFirst()//убрать typename
            lexemList.removeFirst()//убрать space
            lexemList.removeLast()//убрать delimiter
            if(lexemList.stream().anyMatch {
                    it != LexemNames.COMMA && it != LexemNames.SPACE && it != LexemNames.IDENT
                })
            {
                println("ОШИБКА описания списка переменных!")
            } else{
                while (lexemList.size>1){
                    if(lexemList.first()!= LexemNames.IDENT && lexemList[1] != LexemNames.COMMA){
                        println("Ошибка порядка следования лексем")
                        break;
                    } else {
                        println("правило: ${LexemNames.IDENT} ${LexemNames.COMMA} LIST<VARIABLES>")
                        lexemList.removeFirst()//убрать идентт
                        lexemList.removeFirst()//убрать space
                        lexemList.removeFirst()//убрать comma

                    }
                }
                // последний идентификатор в списке идентификаторов
                if(lexemList.size != 0){
                    if(lexemList.first() != LexemNames.IDENT){
                        println("Ошибка порядка следования лексем")
                    }
                    else{
                        println("правило: ${LexemNames.IDENT}")
                        lexemList.removeFirst()
                    }
                }
                //разбирать программу дальше
            }
        }
    }
}

fun containsUndefined(text: String): Boolean{
    var reg = Pattern.compile("[A-Za-z]")
    var matcher = reg.matcher(text)
    var t = matcher.replaceAll("")
    println(t)
    reg = Pattern.compile("[0-9]")
    matcher = reg.matcher(t)
    t = matcher.replaceAll("")
    lexems.forEach {
        reg = Pattern.compile(it.value)
        matcher = reg.matcher(t)
        t = matcher.replaceAll("")
    }
    return t.isNotEmpty()
}

fun firstIndexOfUndefined(text: String): Int{
    for(i in text.indices) {
        if(!(text[i].isDigit() || text[i].isLetter())){
            if(!lexems.any { lexem -> lexem.value.contains(text[i])}){
                return i
            }
        }
    }
    return -1
}